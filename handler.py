"""Service entry-point."""
import json
import logging

from service.dal import Project
from service.models import JSONManifest, JSONFactory


# Logging setup
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


# Lambda entry
def main(event, context=None):  # pylint: disable=unused-argument
    """Handle loandata as Eventbridge event and return report.

    The reports generated by the service have the following envelope:

    ```json
    {
        "reports": [
            {
                "title": "<the report title>",
                ...
            },
            ...
        ]
    }
    ```

    Parameters
    ----------
    event : dict
        The Eventbridge event payload with loandata for reporting as its detail.
    context : LambdaContext
        The lambda context object (for Lambda use only).

    Returns
    -------
    dict{str:any}
        Returns a dict which contains the reports generated by the service.

    """
    event = {} if event is None else event
    logger.info('Service invoked by event: %s', json.dumps(event, indent=2))

    # Load all rules
    project = Project()
    rules = [rule for _ in project.resources.values() for rule in _]
    logger.info('Service loaded rules: %s', json.dumps(rules, indent=2))

    # Confirm event is valid EventBridge -> SQS payload
    loans = []
    for record in event.get('Records', [{}]):
        if not all(
            key in record for key in ['source', 'detail-type', 'detail']
        ):
            logger.error(
                'Service received invalid EventBridge event- Skipping event'
            )
            continue

        # Attempt to load loandata
        try:
            loans.append(json.loads(record['detail']))
        except json.JSONDecodeError:
            logger.error(
                'Service received invalid event detail- Skipping event'
            )
            continue

    logger.info('Service recieved loans: %s', json.dumps(loans, indent=2))

    mailing_keys = [
        'addressStreetLine1',
        'addressCity',
        'addressState',
        'addressPostalCode'
    ]

    # Generate Manifests
    reports = []
    for loan in loans:
        try:
            assert ('applications' in loan), 'missing applications'
            # Only using the first application for residence reports
            app = loan['applications'][0]
            assert ('borrower' in app), 'missing borrower'
            assert ('coborrower' in app), 'missing coborrower'
            borrower = app['borrower']
            coborrower = app['coborrower']
            assert ('mailingAddress' in borrower), 'missing mailingAddress from borrower'
            assert ('mailingAddress' in coborrower), 'missing mailingAddress from coborrower'
            for key in mailing_keys:
                assert (key in borrower['mailingAddress']), 'missing %s from borrower mailing address' % key
                assert (key in coborrower['mailingAddress']), 'missing %s from coborrower mailing address' % key

            # FTR CC-01
            if borrower['mailingAddress'] == coborrower['mailingAddress']:
                index = 0
                while index < len(rules):
                    if 'coborrower.mailingAddress' in rules[index]['source']:
                        del rules[index]
                    else:
                        index += 1

            manifest = JSONManifest(loan, rules)
            logger.info(
                'Generated manifest: %s', json.dumps(manifest.items, indent=2)
            )

            projection = JSONFactory(manifest).get_projection()
            logger.info(
                'Generated projection: %s', json.dumps(projection, indent=2)
            )

            reports.extend(projection.get('reports', []))
        except Exception as e:
            logger.error('Service received invalid loan data -%s- Skipping event', str(e))

    # FTR CC-01 Extra
    # Remove duplicate residences:
    # What if there happens to be multiple applicants with the same
    # residence address, or multiple loans with the same applicants?
    # here, the duplicates will be removed

    for item in reports:
        if item['title'] == 'Residences Report':
            tmp = []
            for index in range(len(item['residences'])):
                residence = item['residences'][index]
                if residence in tmp:
                    del item['residences'][index]
                else:
                    tmp.append(residence)


    # Reformat report output and return
    return {'reports': reports}
